<div align="center">
  <img height="150" src="https://www.tutorialspoint.com/data_structures_algorithms/images/linear_search.gif"  />
</div>

###

<h1 align="center">C  C++ DSA  Algorithms</h1>
 
###

**Algorithm Complexities - Notes**

## **Algorithm Complexity Table**
<h6> 
  
| **Algorithm Type** | **Algorithm**       | **Best Case** | **Average Case** | **Worst Case** | **Space Complexity** |
|--------------------|---------------------|--------------|----------------|--------------|----------------|
| **Searching**      | Linear Search       | O(1)         | O(n)           | O(n)         | O(1)           |
|                    | Binary Search       | O(1)         | O(log n)       | O(log n)     | O(1)           |
| **Sorting**        | Bubble Sort         | O(n)         | O(n¬≤)          | O(n¬≤)        | O(1)           |
|                    | Selection Sort      | O(n¬≤)        | O(n¬≤)          | O(n¬≤)        | O(1)           |
|                    | Insertion Sort      | O(n)         | O(n¬≤)          | O(n¬≤)        | O(1)           |
|                    | Merge Sort          | O(n log n)   | O(n log n)     | O(n log n)   | O(n)           |
|                    | Quick Sort          | O(n log n)   | O(n log n)     | O(n¬≤)        | O(log n)       |
|                    | Heap Sort           | O(n log n)   | O(n log n)     | O(n log n)   | O(1)           |
|                    | Counting Sort       | O(n + k)     | O(n + k)       | O(n + k)     | O(k)           |
|                    | Radix Sort          | O(nk)        | O(nk)          | O(nk)        | O(n + k)       |
|                    | Bucket Sort         | O(n + k)     | O(n + k)       | O(n¬≤)        | O(n)           |
| **Graph**          | BFS (Adj. List)     | O(V + E)     | O(V + E)       | O(V + E)     | O(V)           |
|                    | DFS (Adj. List)     | O(V + E)     | O(V + E)       | O(V + E)     | O(V)           |
|                    | Dijkstra (Heap)     | O((V + E) log V) | O((V + E) log V) | O((V + E) log V) | O(V + E)       |
|                    | Bellman-Ford        | O(VE)        | O(VE)          | O(VE)        | O(V)           |
|                    | Floyd-Warshall      | O(n¬≥)        | O(n¬≥)          | O(n¬≥)        | O(n¬≤)          |
|                    | Kruskal‚Äôs Algorithm | O(E log E)   | O(E log E)     | O(E log E)   | O(E + V)       |
|                    | Prim‚Äôs Algorithm    | O((V + E) log V) | O((V + E) log V) | O((V + E) log V) | O(V¬≤) or O(E + V) with heap |

</h6>


---

### **Conclusion**
Understanding time and space complexity is crucial for optimizing algorithms. Always consider the input size and constraints to choose the most efficient algorithm. 

Let me know if you need any modifications or explanations! üöÄ


## Algorithm and Data Structure (DSA) - Study Guide

<h6> 

## Content
1. [‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£](#‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ-‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£-algorithm-analysis)
2. [‡¶∏‡¶æ‡¶∞‡ßç‡¶ö‡¶ø‡¶Ç ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ](#‡¶∏‡¶æ‡¶∞‡ßç‡¶ö‡¶ø‡¶Ç-‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ-searching-algorithms)
3. [‡¶∏‡¶∞‡ßç‡¶ü‡¶ø‡¶Ç ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ](#‡¶∏‡¶∞‡ßç‡¶ü‡¶ø‡¶Ç-‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ-sorting-algorithms)
4. [‡¶ó‡ßç‡¶∞‡¶æ‡¶´ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ](#‡¶ó‡ßç‡¶∞‡¶æ‡¶´-‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ-graph-algorithms)
5. [‡¶ó‡ßç‡¶∞‡¶ø‡¶°‡¶ø ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ](#‡¶ó‡ßç‡¶∞‡¶ø‡¶°‡¶ø-‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ-greedy-algorithms)
6. [‡¶°‡¶æ‡ßü‡¶®‡¶æ‡¶Æ‡¶ø‡¶ï ‡¶™‡ßç‡¶∞‡ßã‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ‡¶ø‡¶Ç](#‡¶°‡¶æ‡ßü‡¶®‡¶æ‡¶Æ‡¶ø‡¶ï-‡¶™‡ßç‡¶∞‡ßã‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ‡¶ø‡¶Ç-dynamic-programming)
7. [‡¶°‡¶ø‡¶≠‡¶æ‡¶á‡¶° ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶° ‡¶ï‡¶®‡¶ï‡ßã‡ßü‡¶æ‡¶∞](#‡¶°‡¶ø‡¶≠‡¶æ‡¶á‡¶°-‡¶Ö‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°-‡¶ï‡¶®‡¶ï‡ßã‡ßü‡¶æ‡¶∞-divide-and-conquer)
8. [‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï‡¶ø‡¶Ç](#‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï‡¶ø‡¶Ç-backtracking)
9. [‡¶¨‡¶ø‡¶ü ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡¶ø‡¶™‡ßÅ‡¶≤‡ßá‡¶∂‡¶®](#‡¶¨‡¶ø‡¶ü-‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡¶ø‡¶™‡ßÅ‡¶≤‡ßá‡¶∂‡¶®-bit-manipulation)
10. [‡¶â‡¶®‡ßç‡¶®‡¶§ ‡¶°‡¶æ‡¶ü‡¶æ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞](#‡¶â‡¶®‡ßç‡¶®‡¶§-‡¶°‡¶æ‡¶ü‡¶æ-‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞-advanced-data-structures)
11. [‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶ø‡¶Ç ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ](#‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶ø‡¶Ç-‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ-string-algorithms)
12. [‡¶ï‡¶Æ‡ßç‡¶™‡¶ø‡¶â‡¶ü‡ßá‡¶∂‡¶®‡¶æ‡¶≤ ‡¶ú‡¶ø‡¶ì‡¶Æ‡ßá‡¶ü‡ßç‡¶∞‡¶ø](#‡¶ï‡¶Æ‡ßç‡¶™‡¶ø‡¶â‡¶ü‡ßá‡¶∂‡¶®‡¶æ‡¶≤-‡¶ú‡¶ø‡¶ì‡¶Æ‡ßá‡¶ü‡ßç‡¶∞‡¶ø-computational-geometry)

</h6>
---

### ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£ (Algorithm Analysis)

- **‡¶ü‡¶æ‡¶á‡¶Æ ‡¶ï‡¶Æ‡¶™‡ßç‡¶≤‡ßá‡¶ï‡ßç‡¶∏‡¶ø‡¶ü‡¶ø**: ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ‡ßá‡¶∞ ‡¶∞‡¶æ‡¶® ‡¶ü‡¶æ‡¶á‡¶Æ ‡¶®‡¶ø‡¶∞‡ßç‡¶ß‡¶æ‡¶∞‡¶£ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§ ‡¶π‡ßü‡•§ ‡¶è‡¶ü‡¶ø **Big-O**, **Big-Œ©**, ‡¶è‡¶¨‡¶Ç **Big-Œò** ‡¶¶‡ßç‡¶¨‡¶æ‡¶∞‡¶æ ‡¶™‡ßç‡¶∞‡¶ï‡¶æ‡¶∂ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡•§
- **‡¶∏‡ßç‡¶™‡ßá‡¶∏ ‡¶ï‡¶Æ‡¶™‡ßç‡¶≤‡ßá‡¶ï‡ßç‡¶∏‡¶ø‡¶ü‡¶ø**: ‡¶Æ‡ßá‡¶Æ‡ßã‡¶∞‡¶ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡ßá‡¶∞ ‡¶™‡¶∞‡¶ø‡¶Æ‡¶æ‡¶£ ‡¶¨‡ßã‡¶ù‡¶æ‡ßü‡•§
- **‡¶¨‡ßá‡¶∏‡ßç‡¶ü, ‡¶è‡¶≠‡¶æ‡¶∞‡ßá‡¶ú**, ‡¶ì‡ßü‡¶æ‡¶∞‡ßç‡¶∏‡ßç‡¶ü ‡¶ï‡ßá‡¶∏: ‡¶á‡¶®‡¶™‡ßÅ‡¶ü ‡¶≠‡ßá‡¶¶‡ßá ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ‡ßá‡¶∞ ‡¶™‡¶æ‡¶∞‡¶´‡¶∞‡¶Æ‡ßá‡¶®‡ßç‡¶∏ ‡¶ï‡ßá‡¶Æ‡¶® ‡¶π‡¶¨‡ßá ‡¶§‡¶æ ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡•§
- **Amortized Analysis**: ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶Ö‡¶™‡¶æ‡¶∞‡ßá‡¶∂‡¶®‡ßá‡¶∞ ‡¶ó‡ßú ‡¶ï‡¶Æ‡¶™‡ßç‡¶≤‡ßá‡¶ï‡ßç‡¶∏‡¶ø‡¶ü‡¶ø ‡¶®‡¶ø‡¶∞‡ßç‡¶ß‡¶æ‡¶∞‡¶£ ‡¶ï‡¶∞‡¶æ‡•§

---

### ‡¶∏‡¶æ‡¶∞‡ßç‡¶ö‡¶ø‡¶Ç ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ (Searching Algorithms)

- **Linear Search**: ***`O(n)`*** ‚Äì ‡¶è‡¶ï‡¶ü‡¶ø ‡¶è‡¶≤‡¶ø‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶ñ‡ßã‡¶Å‡¶ú‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶™‡ßÅ‡¶∞‡ßã ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶∞ ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶Ü‡¶á‡¶ü‡ßá‡¶Æ ‡¶™‡¶∞‡ßÄ‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡•§
- **Binary Search**: ***`O(log n)`*** ‚Äì ‡¶á‡¶®‡¶™‡ßÅ‡¶ü ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü ‡¶Ø‡¶¶‡¶ø ‡¶∏‡¶∞‡ßç‡¶ü‡ßá‡¶° ‡¶•‡¶æ‡¶ï‡ßá ‡¶§‡¶¨‡ßá ‡¶¨‡¶æ‡¶á‡¶®‡¶æ‡¶∞‡¶ø ‡¶∏‡¶æ‡¶∞‡ßç‡¶ö ‡¶è‡¶≤‡¶ø‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶ñ‡ßã‡¶Å‡¶ú‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§‡¶§‡¶∞ ‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø‡•§
- **Ternary Search**: ***`O(log n)`*** ‚Äì ‡¶§‡¶ø‡¶® ‡¶≠‡¶æ‡¶ó‡ßá ‡¶≠‡¶æ‡¶ó ‡¶ï‡¶∞‡ßá ‡¶Ö‡¶®‡ßÅ‡¶∏‡¶®‡ßç‡¶ß‡¶æ‡¶® ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡•§
- **Interpolation Search**: ***`O(log log n)`*** ‚Äì Binary Search ‡¶è‡¶∞ ‡¶â‡¶®‡ßç‡¶®‡¶§ ‡¶∏‡¶Ç‡¶∏‡ßç‡¶ï‡¶∞‡¶£‡•§
- **Exponential Search**: ***`O(log n)`*** ‚Äì ‡¶è‡¶≤‡¶ø‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∞ ‡¶Ö‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡¶® ‡¶Ö‡¶ú‡¶æ‡¶®‡¶æ ‡¶π‡¶≤‡ßá ‡¶è‡¶ü‡¶ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶π‡ßü‡•§

---

### ‡¶∏‡¶∞‡ßç‡¶ü‡¶ø‡¶Ç ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ (Sorting Algorithms)

- **Bubble Sort**: ***`O(n^2)`*** ‚Äì ‡¶è‡¶ï‡ßá‡¶∞ ‡¶™‡¶∞ ‡¶è‡¶ï ‡¶∏‡¶®‡ßç‡¶®‡¶ø‡¶¨‡ßá‡¶∂‡¶ø‡¶§ ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶®‡¶ó‡ßÅ‡¶≤‡ßã ‡¶§‡ßÅ‡¶≤‡¶®‡¶æ ‡¶ï‡¶∞‡ßá ‡¶∏‡¶∞‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡•§
- **Selection Sort**: ***`O(n^2)`*** ‚Äì ‡¶è‡¶ï‡¶ü‡¶ø ‡¶õ‡ßã‡¶ü‡¶§‡¶Æ ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶®‡¶ï‡ßá ‡¶®‡¶ø‡¶∞‡ßç‡¶¨‡¶æ‡¶ö‡¶® ‡¶ï‡¶∞‡ßá ‡¶∏‡ßá‡¶ü‡¶ø ‡¶∏‡¶†‡¶ø‡¶ï ‡¶∏‡ßç‡¶•‡¶æ‡¶®‡ßá ‡¶∞‡¶æ‡¶ñ‡¶æ‡¶∞ ‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø‡•§
- **Insertion Sort**: ***`O(n^2)`*** ‚Äì ‡¶è‡¶≤‡¶ø‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡¶ó‡ßÅ‡¶≤‡¶ø‡¶ï‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ï‡¶∞‡ßá ‡¶á‡¶®‡¶∏‡¶æ‡¶∞‡ßç‡¶ü ‡¶ï‡¶∞‡ßá ‡¶á‡¶®‡¶™‡ßÅ‡¶ü ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶∞‡ßá ‡¶∏‡¶∞‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡•§
- **Merge Sort**: ***`O(n log n)`*** ‚Äì ‡¶¨‡¶ø‡¶≠‡¶æ‡¶ú‡¶® ‡¶è‡¶¨‡¶Ç ‡¶ú‡¶Ø‡¶º‡ßá‡¶®‡¶ø‡¶Ç ‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶è‡¶≤‡¶ø‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶∏‡¶æ‡¶ú‡¶æ‡¶®‡ßã ‡¶π‡ßü‡•§
- **Quick Sort**: ***`O(n log n)`*** ‚Äì ‡¶™‡¶ø‡¶≠‡¶ü ‡¶è‡¶≤‡¶ø‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶∏‡¶∞‡ßç‡¶ü‡¶ø‡¶Ç ‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø‡•§
- **Heap Sort**: ***`O(n log n)`*** ‚Äì ‡¶è‡¶ï‡¶ü‡¶ø ‡¶π‡¶ø‡¶™ ‡¶°‡¶æ‡¶ü‡¶æ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶è‡¶≤‡¶ø‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶∏‡¶∞‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡•§

---

### ‡¶ó‡ßç‡¶∞‡¶æ‡¶´ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ (Graph Algorithms)

- **DFS (Depth First Search)**: ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ó‡ßç‡¶∞‡¶æ‡¶´‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶ó‡¶≠‡ßÄ‡¶∞‡¶§‡¶æ‡¶∞ ‡¶≠‡¶ø‡¶§‡ßç‡¶§‡¶ø‡¶§‡ßá ‡¶Ö‡¶®‡ßÅ‡¶∏‡¶®‡ßç‡¶ß‡¶æ‡¶® ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡•§
- **BFS (Breadth First Search)**: ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ó‡ßç‡¶∞‡¶æ‡¶´‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶•‡ßá‡¶∞ ‡¶≠‡¶ø‡¶§‡ßç‡¶§‡¶ø‡¶§‡ßá ‡¶Ö‡¶®‡ßÅ‡¶∏‡¶®‡ßç‡¶ß‡¶æ‡¶® ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡•§
- **Dijkstra's Algorithm**: ‡¶∏‡¶∞‡ßç‡¶¨‡¶®‡¶ø‡¶Æ‡ßç‡¶® ‡¶¶‡ßÇ‡¶∞‡¶§‡ßç‡¶¨‡ßá‡¶∞ ‡¶™‡¶•‡ßá ‡¶Ø‡¶æ‡¶ì‡ßü‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ‡•§
- **Bellman-Ford Algorithm**: ‡¶®‡ßá‡¶§‡¶ø‡¶¨‡¶æ‡¶ö‡¶ï ‡¶ì‡ßü‡ßá‡¶ü ‡¶∏‡¶π ‡¶∏‡¶∞‡ßç‡¶¨‡¶®‡¶ø‡¶Æ‡ßç‡¶® ‡¶™‡¶• ‡¶®‡¶ø‡¶∞‡ßç‡¶ß‡¶æ‡¶∞‡¶£‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§ ‡¶π‡ßü‡•§
- **Floyd-Warshall Algorithm**: ‡¶∏‡¶Æ‡¶∏‡ßç‡¶§ ‡¶¶‡¶Æ‡ßç‡¶™‡¶§‡¶ø ‡¶®‡ßã‡¶°‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶∏‡¶∞‡ßç‡¶¨‡¶®‡¶ø‡¶Æ‡ßç‡¶® ‡¶™‡¶• ‡¶ñ‡ßã‡¶Å‡¶ú‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§ ‡¶π‡ßü‡•§

---

### ‡¶ó‡ßç‡¶∞‡¶ø‡¶°‡¶ø ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ (Greedy Algorithms)

- **Activity Selection Problem**: ‡¶®‡¶ø‡¶∞‡ßç‡¶¨‡¶æ‡¶ö‡¶ø‡¶§ ‡¶ï‡¶∞‡ßç‡¶Æ‡¶ï‡¶æ‡¶£‡ßç‡¶°‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶∏‡¶∞‡ßç‡¶¨‡¶æ‡¶ß‡¶ø‡¶ï ‡¶∏‡¶Æ‡ßü‡ßá ‡¶ï‡¶æ‡¶ú‡ßá ‡¶≤‡¶æ‡¶ó‡¶æ‡¶®‡ßã‡¶∞ ‡¶ï‡ßå‡¶∂‡¶≤‡•§
- **Huffman Coding**: ‡¶°‡¶æ‡¶ü‡¶æ ‡¶∏‡¶Ç‡¶ï‡ßã‡¶ö‡¶® ‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶π‡¶æ‡¶´‡¶Æ‡ßç‡¶Ø‡¶æ‡¶® ‡¶ü‡ßç‡¶∞‡¶ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡•§
- **Fractional Knapsack**: ‡¶™‡¶£‡ßç‡¶Ø‡ßá‡¶∞ ‡¶≠‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶Ø‡¶æ‡ßü‡ßÄ ‡¶∏‡¶∞‡ßç‡¶¨‡¶æ‡¶ß‡¶ø‡¶ï ‡¶≤‡¶æ‡¶≠ ‡¶Ö‡¶∞‡ßç‡¶ú‡¶® ‡¶ï‡¶∞‡¶§‡ßá ‡¶ó‡ßç‡¶∞‡¶ø‡¶°‡¶ø ‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§ ‡¶π‡ßü‡•§
- **Prim's Algorithm**: ‡¶Æ‡¶ø‡¶®‡¶ø‡¶Æ‡¶æ‡¶Æ ‡¶∏‡ßç‡¶™‡ßç‡¶Ø‡¶æ‡¶®‡¶ø‡¶Ç ‡¶ü‡ßç‡¶∞‡¶ø ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§‡•§

---

### ‡¶°‡¶æ‡ßü‡¶®‡¶æ‡¶Æ‡¶ø‡¶ï ‡¶™‡ßç‡¶∞‡ßã‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ‡¶ø‡¶Ç (Dynamic Programming)

- **Fibonacci Sequence**: **O(n)** ‡¶∏‡¶Æ‡ßü‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶´‡¶ø‡¶¨‡ßã‡¶®‡¶æ‡¶ö‡ßç‡¶ö‡¶ø ‡¶∏‡¶ø‡¶∞‡¶ø‡¶ú ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ‡•§
- **Knapsack Problem**: ‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡¶∏‡ßç‡¶§‡ßÅ ‡¶®‡¶ø‡¶∞‡ßç‡¶¨‡¶æ‡¶ö‡¶® ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶∏‡¶∞‡ßç‡¶¨‡¶æ‡¶ß‡¶ø‡¶ï ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø ‡¶®‡¶ø‡¶∞‡ßç‡¶ß‡¶æ‡¶∞‡¶£ ‡¶ï‡¶∞‡¶§‡ßá ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§ ‡¶π‡ßü‡•§
- **Longest Common Subsequence**: ‡¶¶‡ßÅ‡¶ü‡¶ø ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶ø‡¶Ç‡ßü‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶∏‡¶¨‡¶ö‡ßá‡ßü‡ßá ‡¶¨‡ßú ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶∏‡¶æ‡¶¨‡¶∏‡¶ø‡¶ï‡ßã‡ßü‡ßá‡¶®‡ßç‡¶∏ ‡¶®‡¶ø‡¶∞‡ßç‡¶ß‡¶æ‡¶∞‡¶£ ‡¶ï‡¶∞‡¶æ‡•§
- **Longest Increasing Subsequence**: ‡¶è‡¶ï‡¶ß‡¶æ‡¶™ ‡¶¨‡¶æ‡ßú‡¶æ‡¶®‡ßã ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶®‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶∏‡¶¨‡¶ö‡ßá‡ßü‡ßá ‡¶¨‡ßú ‡¶â‡¶™‡¶∏‡ßá‡¶ü ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ‡•§

---

### ‡¶°‡¶ø‡¶≠‡¶æ‡¶á‡¶° ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶° ‡¶ï‡¶®‡¶ï‡ßã‡ßü‡¶æ‡¶∞ (Divide and Conquer)

- **Merge Sort**: ‡¶â‡¶™‡¶∞‡ßá‡¶∞ ‡¶Æ‡¶§‡ßã, ‡¶°‡¶ø‡¶≠‡¶æ‡¶á‡¶° ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶° ‡¶ï‡¶®‡¶ï‡ßã‡ßü‡¶æ‡¶∞ ‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶∏‡¶∞‡ßç‡¶ü‡¶ø‡¶Ç ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ‡•§
- **Quick Sort**: ‡¶á‡¶®‡¶™‡ßÅ‡¶ü ‡¶°‡¶æ‡¶ü‡¶æ ‡¶≠‡¶æ‡¶ó ‡¶ï‡¶∞‡ßá ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶∏‡¶∞‡ßç‡¶ü‡¶ø‡¶Ç ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§‡•§
- **Binary Search**: ‡¶á‡¶®‡¶™‡ßÅ‡¶ü ‡¶°‡¶æ‡¶ü‡¶æ ‡¶≠‡¶æ‡¶ó ‡¶ï‡¶∞‡ßá ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶Ö‡¶®‡ßÅ‡¶∏‡¶®‡ßç‡¶ß‡¶æ‡¶® ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡•§

---

### ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï‡¶ø‡¶Ç (Backtracking)

- **N-Queens Problem**: ‡¶è‡¶ï‡¶ü‡¶ø ‡¶è‡¶®-‡¶ï‡ßÅ‡ßü‡¶ø‡¶®‡ßç‡¶∏‡ßá‡¶∞ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶® ‡¶ï‡¶∞‡¶æ ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶ï‡ßÅ‡¶á‡¶®‡¶¶‡ßá‡¶∞ ‡¶™‡¶∞‡¶∏‡ßç‡¶™‡¶∞‡¶ï‡ßá ‡¶Ü‡¶ï‡ßç‡¶∞‡¶Æ‡¶£ ‡¶®‡¶æ ‡¶ï‡¶∞‡ßá ‡¶¨‡¶∏‡¶æ‡¶®‡ßã ‡¶π‡ßü‡•§
- **Subset Sum Problem**: ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶æ‡¶¨‡¶∏‡ßá‡¶ü ‡¶ñ‡ßã‡¶Å‡¶ú‡¶æ ‡¶Ø‡¶æ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡¶ø‡¶∑‡ßç‡¶ü ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶Ø‡ßã‡¶ó‡¶´‡¶≤ ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá‡•§
- **Sudoku Solver**: ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡ßÅ‡¶¶‡ßã‡¶ï‡ßÅ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶® ‡¶ï‡¶∞‡¶æ‡•§

---

### ‡¶¨‡¶ø‡¶ü ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡¶ø‡¶™‡ßÅ‡¶≤‡ßá‡¶∂‡¶® (Bit Manipulation)

- **Bitwise AND, OR, XOR**: ‡¶¨‡¶ø‡¶ü‡¶ì‡ßü‡¶æ‡¶á‡¶ú ‡¶Ö‡¶™‡¶æ‡¶∞‡ßá‡¶∂‡¶® ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø‡•§
- **Checking if a number is power of 2**: ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡ß® ‡¶è‡¶∞ ‡¶∂‡¶ï‡ßç‡¶§‡¶ø ‡¶ï‡¶ø‡¶®‡¶æ ‡¶§‡¶æ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡¶æ‡•§
- **Counting set bits**: ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶∞ ‡¶∏‡ßá‡¶ü ‡¶¨‡¶ø‡¶ü ‡¶ó‡¶£‡¶®‡¶æ ‡¶ï‡¶∞‡¶æ‡•§

---

### ‡¶â‡¶®‡ßç‡¶®‡¶§ ‡¶°‡¶æ‡¶ü‡¶æ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ (Advanced Data Structures)

- **Trie**: ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ü‡ßç‡¶∞‡¶ø ‡¶°‡¶æ‡¶ü‡¶æ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ ‡¶Ø‡¶æ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶ø‡¶Ç ‡¶Ö‡¶®‡ßÅ‡¶∏‡¶®‡ßç‡¶ß‡¶æ‡¶®‡ßá ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§ ‡¶π‡ßü‡•§
- **Segment Tree**: ‡¶è‡¶ï‡¶ü‡¶ø ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶∞‡ßá ‡¶™‡¶∞‡¶ø‡¶∏‡¶∞‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶ï‡ßÅ‡¶á‡¶∞‡¶ø ‡¶è‡¶¨‡¶Ç ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶Ö‡¶™‡¶æ‡¶∞‡ßá‡¶∂‡¶® ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§ ‡¶π‡ßü‡•§
- **Fenwick Tree (Binary Indexed Tree)**: ‡¶è‡¶ï‡¶ü‡¶ø ‡¶°‡¶æ‡¶ü‡¶æ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ ‡¶Ø‡¶æ ‡¶ï‡ßÅ‡¶á‡¶∞‡¶ø ‡¶ì ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶Ö‡¶™‡¶æ‡¶∞‡ßá‡¶∂‡¶® ‡¶ï‡¶æ‡¶∞‡ßç‡¶Ø‡¶ï‡¶∞‡¶≠‡¶æ‡¶¨‡ßá ‡¶∏‡¶Æ‡ßç‡¶™‡¶æ‡¶¶‡¶® ‡¶ï‡¶∞‡¶§‡ßá ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§ ‡¶π‡ßü‡•§
- **Disjoint Set (Union-Find)**: ‡¶è‡¶ï‡¶ü‡¶ø ‡¶°‡¶æ‡¶ü‡¶æ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ ‡¶Ø‡¶æ ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶®‡¶ó‡ßÅ‡¶≤‡ßã‡¶ï‡ßá ‡¶∏‡¶Æ‡¶ø‡¶§‡¶ø ‡¶¨‡¶æ ‡¶ï‡ßç‡¶≤‡¶æ‡¶∏‡ßá ‡¶≠‡¶æ‡¶ó ‡¶ï‡¶∞‡¶§‡ßá ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§ ‡¶π‡ßü‡•§

---

### ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶ø‡¶Ç ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ (String Algorithms)

- **Naive Pattern Searching**: ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶ø‡¶Ç‡ßü‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶™‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∞‡ßç‡¶® ‡¶ñ‡ßã‡¶Å‡¶ú‡¶æ‡¶∞ ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø‡•§
- **KMP (Knuth-Morris-Pratt)**: ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶™‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∞‡ßç‡¶® ‡¶Ö‡¶®‡ßÅ‡¶∏‡¶®‡ßç‡¶ß‡¶æ‡¶®‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶è‡¶ï‡¶ü‡¶ø ‡¶â‡¶®‡ßç‡¶®‡¶§ ‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø‡•§
- **Rabin-Karp**: ‡¶π‡ßç‡¶Ø‡¶æ‡¶∂‡¶ø‡¶Ç ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶ø‡¶Ç ‡¶™‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∞‡ßç‡¶® ‡¶Ö‡¶®‡ßÅ‡¶∏‡¶®‡ßç‡¶ß‡¶æ‡¶® ‡¶ï‡¶∞‡¶æ‡•§
- **Z Algorithm**: ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶ø‡¶Ç ‡¶™‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∞‡ßç‡¶® ‡¶ñ‡ßã‡¶Å‡¶ú‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∂‡¶ï‡ßç‡¶§‡¶ø‡¶∂‡¶æ‡¶≤‡ßÄ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ‡•§

---

### ‡¶ï‡¶Æ‡ßç‡¶™‡¶ø‡¶â‡¶ü‡ßá‡¶∂‡¶®‡¶æ‡¶≤ ‡¶ú‡¶ø‡¶ì‡¶Æ‡ßá‡¶ü‡ßç‡¶∞‡¶ø (Computational Geometry)

- **Convex Hull**: ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶®‡ßç‡¶®‡¶ø‡¶¨‡ßá‡¶∂‡¶ø‡¶§ ‡¶™‡ßü‡ßá‡¶®‡ßç‡¶ü‡¶∏‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶∏‡¶∞‡ßç‡¶¨‡¶®‡¶ø‡¶Æ‡ßç‡¶® ‡¶Ü‡¶ï‡¶æ‡¶∞‡ßá‡¶∞ ‡¶¨‡¶æ‡¶â‡¶®‡ßç‡¶°‡¶ø‡¶Ç ‡¶π‡¶æ‡¶≤‡ßç‡¶≤ ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ‡•§
- **Line Intersection**: ‡¶¶‡ßÅ‡¶ü‡¶ø ‡¶≤‡¶æ‡¶á‡¶® ‡¶è‡¶ï‡ßá ‡¶Ö‡¶™‡¶∞‡¶ï‡ßá ‡¶õ‡ßá‡¶¶ ‡¶ï‡¶∞‡ßá ‡¶ï‡¶ø‡¶®‡¶æ ‡¶§‡¶æ ‡¶Ø‡¶æ‡¶ö‡¶æ‡¶á ‡¶ï‡¶∞‡¶æ‡•§
- **Point in Polygon**: ‡¶è‡¶ï‡¶ü‡¶ø ‡¶™‡ßü‡ßá‡¶®‡ßç‡¶ü ‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡¶π‡ßÅ‡¶™‡¶¶‡ßÄ (polygon) ‡¶è‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶Ö‡¶¨‡¶∏‡ßç‡¶•‡¶ø‡¶§ ‡¶ï‡¶ø‡¶®‡¶æ ‡¶§‡¶æ ‡¶™‡¶∞‡ßÄ‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡¶æ‡•§

---

<br>
<br>
<br>





















## Here's a detailed explanation of the Data Structures and Algorithms (DSA) topics in C++ with examples and explanations in Bangla:

### 1. ‡¶¨‡ßá‡¶∏‡¶ø‡¶ï ‡¶°‡¶æ‡¶ü‡¶æ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ (Basic Data Structures)
#### Array (‡¶è‡¶∞‡ßá):
Array ‡¶π‡¶≤ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡¶ø‡¶∑‡ßç‡¶ü ‡¶Ü‡¶ï‡¶æ‡¶∞‡ßá‡¶∞ ‡¶°‡¶æ‡¶ü‡¶æ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶è‡¶ï‡¶∏‡¶æ‡¶•‡ßá ‡¶è‡¶ï‡¶æ‡¶ß‡¶ø‡¶ï ‡¶°‡¶æ‡¶ü‡¶æ ‡¶∏‡ßç‡¶ü‡ßã‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü‡•§

```cpp
#include <iostream>
using namespace std;

int main() {
    int arr[] = {1, 2, 3, 4, 5};  // Array Declaration
    cout << "Array Element at index 0: " << arr[0] << endl;
    return 0;
}

```

###### ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ: ‡¶è‡¶ñ‡¶æ‡¶®‡ßá, ‡¶è‡¶ï‡¶ü‡¶ø ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶∞‡ßá arr[] ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá ‡¶Ø‡¶æ 5‡¶ü‡¶ø ‡¶á‡¶®‡ßç‡¶ü‡¶ø‡¶ú‡¶æ‡¶∞ ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶ï‡¶∞‡ßá‡•§

### Linked List (‡¶≤‡¶ø‡¶ô‡ßç‡¶ï‡¶° ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü):
##### Linked List ‡¶è‡¶ï‡¶ü‡¶ø ‡¶≤‡¶ø‡¶®‡¶ø‡ßü‡¶æ‡¶∞ ‡¶°‡¶æ‡¶ü‡¶æ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞, ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶®‡ßã‡¶°‡ßá ‡¶°‡¶æ‡¶ü‡¶æ ‡¶•‡¶æ‡¶ï‡ßá ‡¶è‡¶¨‡¶Ç ‡¶™‡¶∞‡¶¨‡¶∞‡ßç‡¶§‡ßÄ ‡¶®‡ßã‡¶°‡ßá‡¶∞ ‡¶™‡ßü‡ßá‡¶®‡ßç‡¶ü‡¶æ‡¶∞ ‡¶•‡¶æ‡¶ï‡ßá‡•§
Singly Linked List (‡¶∏‡¶ø‡¶ô‡ßç‡¶ó‡¶≤‡¶ø ‡¶≤‡¶ø‡¶ô‡ßç‡¶ï‡¶° ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü):

```cpp

#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

int main() {
    Node* head = new Node(); // Create first node
    head->data = 1;
    head->next = nullptr;

    Node* second = new Node(); // Create second node
    second->data = 2;
    second->next = nullptr;
    
    head->next = second; // Link the first node to second node
    
    cout << "First node data: " << head->data << endl;
    cout << "Second node data: " << second->data << endl;

    return 0;
}
```
###### ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ: ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶ø‡¶ô‡ßç‡¶ó‡¶≤‡¶ø ‡¶≤‡¶ø‡¶ô‡ßç‡¶ï‡¶° ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶¶‡ßÅ‡¶ü‡¶ø ‡¶®‡ßã‡¶° ‡¶∏‡¶Ç‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶∞‡ßü‡ßá‡¶õ‡ßá‡•§

##### Doubly Linked List (‡¶°‡¶æ‡¶¨‡¶≤‡¶ø ‡¶≤‡¶ø‡¶ô‡ßç‡¶ï‡¶° ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü):

```
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* prev;
    Node* next;
};

int main() {
    Node* head = new Node(); // Create first node
    head->data = 1;
    head->prev = nullptr;
    head->next = nullptr;
    
    Node* second = new Node(); // Create second node
    second->data = 2;
    second->prev = head;
    second->next = nullptr;
    
    head->next = second; // Link the first node to second node
    
    cout << "First node data: " << head->data << endl;
    cout << "Second node data: " << second->data << endl;

    return 0;
}
```

###### ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ: ‡¶è‡¶ñ‡¶æ‡¶®‡ßá, Doubly Linked List ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá, ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶®‡ßã‡¶°‡ßá prev ‡¶è‡¶¨‡¶Ç next ‡¶™‡ßü‡ßá‡¶®‡ßç‡¶ü‡¶æ‡¶∞ ‡¶∞‡ßü‡ßá‡¶õ‡ßá‡•§

##### Circular Linked List (‡¶∏‡¶æ‡¶∞‡ßç‡¶ï‡ßÅ‡¶≤‡¶æ‡¶∞ ‡¶≤‡¶ø‡¶ô‡ßç‡¶ï‡¶° ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü):
```cpp
 
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

int main() {
    Node* head = new Node();
    head->data = 1;
    head->next = head;  // Circular Link
    
    cout << "Head node data: " << head->data << endl;

    return 0;
}
```

‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ: ‡¶è‡¶ñ‡¶æ‡¶®‡ßá Circular Linked List ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá, ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶≤‡¶æ‡¶∏‡ßç‡¶ü ‡¶®‡ßã‡¶° ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶®‡ßã‡¶°‡ßá ‡¶∏‡¶Ç‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶•‡¶æ‡¶ï‡ßá‡•§

### Stack (‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶ï):
- Stack ‡¶π‡¶≤ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶°‡¶æ‡¶ü‡¶æ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ ‡¶Ø‡¶æ LIFO (Last In First Out) ‡¶®‡ßÄ‡¶§‡¶ø ‡¶Ö‡¶®‡ßÅ‡¶∏‡¶∞‡¶£ ‡¶ï‡¶∞‡ßá‡•§ ‡¶è‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶§‡¶ø‡¶®‡¶ü‡¶ø ‡¶Æ‡ßÇ‡¶≤ ‡¶Ö‡¶™‡¶æ‡¶∞‡ßá‡¶∂‡¶® ‡¶∞‡ßü‡ßá‡¶õ‡ßá:
- Push Operation: ‡¶è‡¶ï‡¶ü‡¶ø ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶® ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶ï‡ßá ‡¶™‡ßç‡¶∞‡¶¨‡ßá‡¶∂ ‡¶ï‡¶∞‡¶æ‡•§
- Pop Operation: ‡¶∏‡¶∞‡ßç‡¶¨‡¶∂‡ßá‡¶∑ ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶®‡¶ü‡¶ø ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶ï ‡¶•‡ßá‡¶ï‡ßá ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ‡•§
- Peek/Top Operation: ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶∞ ‡¶∂‡ßÄ‡¶∞‡ßç‡¶∑ ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶® ‡¶¶‡ßá‡¶ñ‡¶æ‡•§

```cpp
 
#include <iostream>
#include <stack>
using namespace std;

int main() {
    stack<int> s;
    s.push(10);  // Push 10
    s.push(20);  // Push 20
    cout << "Top element: " << s.top() << endl; // Top element
    s.pop();  // Pop 20
    cout << "Top element after pop: " << s.top() << endl; // Top element after pop
    return 0;
}
```

###### ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ: ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶ï‡ßá 10 ‡¶è‡¶¨‡¶Ç 20 ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá ‡¶è‡¶¨‡¶Ç ‡¶™‡¶∞‡¶¨‡¶∞‡ßç‡¶§‡ßÄ‡¶§‡ßá 20 ‡¶ï‡ßá ‡¶™‡¶™ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§

### Queue (‡¶ï‡¶ø‡¶â):
- Queue ‡¶π‡¶≤ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶°‡¶æ‡¶ü‡¶æ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ ‡¶Ø‡¶æ FIFO (First In First Out) ‡¶®‡ßÄ‡¶§‡¶ø ‡¶Ö‡¶®‡ßÅ‡¶∏‡¶∞‡¶£ ‡¶ï‡¶∞‡ßá‡•§
vEnqueue Operation: ‡¶è‡¶ï‡¶ü‡¶ø ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶® ‡¶ï‡¶ø‡¶â‡¶§‡ßá ‡¶™‡ßç‡¶∞‡¶¨‡ßá‡¶∂ ‡¶ï‡¶∞‡¶æ‡•§
- Dequeue Operation: ‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶®‡¶ü‡¶ø ‡¶ï‡¶ø‡¶â ‡¶•‡ßá‡¶ï‡ßá ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ‡•§
- Front Operation: ‡¶ï‡¶ø‡¶â‡ßü‡ßá‡¶∞ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶® ‡¶¶‡ßá‡¶ñ‡¶æ‡•§


```cpp
 
#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<int> q;
    q.push(10);  // Enqueue 10
    q.push(20);  // Enqueue 20
    cout << "Front element: " << q.front() << endl; // Front element
    q.pop();  // Dequeue 10
    cout << "Front element after pop: " << q.front() << endl; // Front element after pop
    return 0;
}
```
##### ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ: ‡¶ï‡¶ø‡¶â‡¶§‡ßá 10 ‡¶è‡¶¨‡¶Ç 20 ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá ‡¶è‡¶¨‡¶Ç ‡¶™‡¶∞‡¶¨‡¶∞‡ßç‡¶§‡ßÄ‡¶§‡ßá 10 ‡¶ï‡ßá ‡¶°‡¶ø‡¶ï‡¶ø‡¶â ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§

### Deque (‡¶°‡¶ø‡¶ï‡ßÅ):
##### Deque ‡¶π‡¶≤ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶°‡¶æ‡¶¨‡¶≤-‡¶è‡¶®‡ßç‡¶°‡ßá‡¶° ‡¶ï‡¶ø‡¶â, ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶®‡¶ó‡ßÅ‡¶≤‡ßã ‡¶¶‡ßÅ‡¶á ‡¶™‡ßç‡¶∞‡¶æ‡¶®‡ßç‡¶§ ‡¶•‡ßá‡¶ï‡ßá ‡¶™‡ßç‡¶∞‡¶¨‡ßá‡¶∂ ‡¶è‡¶¨‡¶Ç ‡¶¨‡ßá‡¶∞ ‡¶π‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡•§

```cpp
 
#include <iostream>
#include <deque>
using namespace std;

int main() {
    deque<int> dq;
    dq.push_front(10); // Push 10 at front
    dq.push_back(20);  // Push 20 at back
    cout << "Front element: " << dq.front() << endl; // Front element
    cout << "Back element: " << dq.back() << endl;   // Back element
    dq.pop_front(); // Pop 10 from front
    dq.pop_back();  // Pop 20 from back
    return 0;
}
```

###### ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ: ‡¶è‡¶ñ‡¶æ‡¶®‡ßá Deque ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá front ‡¶è‡¶¨‡¶Ç back ‡¶™‡ßç‡¶∞‡¶æ‡¶®‡ßç‡¶§ ‡¶•‡ßá‡¶ï‡ßá ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶® ‡¶™‡ßç‡¶∞‡¶¨‡ßá‡¶∂ ‡¶è‡¶¨‡¶Ç ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§

### Priority Queue (‡¶™‡ßç‡¶∞‡¶æ‡¶á‡¶ì‡¶∞‡¶ø‡¶ü‡¶ø ‡¶ï‡¶ø‡¶â):
##### Priority Queue ‡¶π‡¶≤ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ï‡¶ø‡¶â ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶®‡¶ï‡ßá ‡¶è‡¶ï‡¶ü‡¶ø priority ‡¶¶‡ßá‡¶ì‡ßü‡¶æ ‡¶π‡ßü ‡¶è‡¶¨‡¶Ç ‡¶∏‡¶∞‡ßç‡¶¨‡ßã‡¶ö‡ßç‡¶ö priority ‡¶è‡¶∞ ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶® ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá ‡¶¨‡ßá‡¶∞ ‡¶π‡ßü‡•§

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    priority_queue<int> pq;
    pq.push(10);
    pq.push(20);
    pq.push(15);
    cout << "Top element (Max-Heap): " << pq.top() << endl; // 20
    pq.pop();
    cout << "Top element after pop: " << pq.top() << endl; // 15
    return 0;
}
```

###### ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ: Priority Queue ‡¶è ‡¶∏‡¶∞‡ßç‡¶¨‡ßã‡¶ö‡ßç‡¶ö ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶®‡¶ü‡¶ø (20) ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá ‡¶¨‡ßá‡¶∞ ‡¶π‡ßü‡•§

### 2. ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶≠‡¶æ‡¶®‡ßç‡¶∏‡¶° ‡¶°‡¶æ‡¶ü‡¶æ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ (Advanced Data Structures)
- Binary Tree (‡¶¨‡¶æ‡¶á‡¶®‡¶æ‡¶∞‡¶ø ‡¶ü‡ßç‡¶∞‡¶ø):
- ‡¶è‡¶ï‡¶ü‡¶ø Binary Tree ‡¶π‡¶≤ ‡¶è‡¶Æ‡¶® ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ü‡ßç‡¶∞‡¶ø ‡¶°‡¶æ‡¶ü‡¶æ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶®‡ßã‡¶°‡ßá‡¶∞ ‡¶∏‡¶∞‡ßç‡¶¨‡¶æ‡¶ß‡¶ø‡¶ï ‡¶¶‡ßÅ‡¶ü‡¶ø ‡¶∏‡¶®‡ßç‡¶§‡¶æ‡¶® ‡¶•‡¶æ‡¶ï‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡•§
  
```cpp
 
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* left;
    Node* right;
};

int main() {
    Node* root = new Node();
    root->data = 1;
    root->left = new Node();
    root->right = new Node();
    root->left->data = 2;
    root->right->data = 3;
    
    cout << "Root: " << root->data << endl;
    cout << "Left Child: " << root->left->data << endl;
    cout << "Right Child: " << root->right->data << endl;
    
    return 0;
}
```
###### ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ: ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡¶æ‡¶á‡¶®‡¶æ‡¶∞‡¶ø ‡¶ü‡ßç‡¶∞‡¶ø ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá Root ‡¶è‡¶¨‡¶Ç ‡¶§‡¶æ‡¶∞ Left ‡¶ì Right ‡¶∏‡¶®‡ßç‡¶§‡¶æ‡¶® ‡¶®‡ßã‡¶° ‡¶∞‡ßü‡ßá‡¶õ‡ßá‡•§

### Binary Search Tree (BST):
- Binary Search Tree (BST) ‡¶π‡¶≤ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡¶æ‡¶á‡¶®‡¶æ‡¶∞‡¶ø ‡¶ü‡ßç‡¶∞‡¶ø, ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶®‡ßã‡¶°‡ßá‡¶∞ left ‡¶∏‡¶®‡ßç‡¶§‡¶æ‡¶®‡ßá‡¶∞ ‡¶Æ‡¶æ‡¶® ‡¶§‡¶æ‡¶∞ ‡¶®‡¶ø‡¶ú‡ßá‡¶∞ ‡¶Æ‡¶æ‡¶®‡ßá‡¶∞ ‡¶ö‡ßá‡ßü‡ßá ‡¶õ‡ßã‡¶ü ‡¶è‡¶¨‡¶Ç right ‡¶∏‡¶®‡ßç‡¶§‡¶æ‡¶®‡ßá‡¶∞ ‡¶Æ‡¶æ‡¶® ‡¶§‡¶æ‡¶∞ ‡¶®‡¶ø‡¶ú‡ßá‡¶∞ ‡¶Æ‡¶æ‡¶®‡ßá‡¶∞ ‡¶ö‡ßá‡ßü‡ßá ‡¶¨‡ßú ‡¶π‡ßü‡•§

```cpp
 
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* left;
    Node* right;
};

Node* insert(Node* root, int value) {
    if (root == nullptr) {
        Node* newNode = new Node();
        newNode->data = value;
        newNode->left = newNode->right = nullptr;
        return newNode;
    }
    if (value < root->data) {
        root->left = insert(root->left, value);
    } else {
        root->right = insert(root->right, value);
    }
    return root;
}

int main() {
    Node* root = nullptr;
    root = insert(root, 10);
    root = insert(root, 20);
    root = insert(root, 5);
    
    cout << "Root: " << root->data << endl;   // 10
    cout << "Left Child: " << root->left->data << endl;  // 5
    cout << "Right Child: " << root->right->data << endl; // 20
    
    return 0;
}
```

###### ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ: ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶è‡¶ï‡¶ü‡¶ø BST ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá ‡¶è‡¶¨‡¶Ç ‡¶§‡¶ø‡¶®‡¶ü‡¶ø ‡¶Æ‡¶æ‡¶® (10, 20, 5) ‡¶á‡¶®‡¶∏‡¶æ‡¶∞‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§

### Heap (‡¶π‡¶ø‡¶™):
- Heap ‡¶è‡¶ï‡¶ü‡¶ø ‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¨‡¶æ‡¶á‡¶®‡¶æ‡¶∞‡¶ø ‡¶ü‡ßç‡¶∞‡¶ø ‡¶Ø‡¶æ ‡¶π‡¶ø‡¶™ ‡¶™‡ßç‡¶∞‡¶™‡¶æ‡¶∞‡ßç‡¶ü‡¶ø ‡¶Ö‡¶®‡ßÅ‡¶∏‡¶∞‡¶£ ‡¶ï‡¶∞‡ßá‡•§ ‡¶è‡¶ü‡¶ø ‡¶¶‡ßÅ‡¶ü‡¶ø ‡¶ß‡¶∞‡¶®‡ßá‡¶∞ ‡¶π‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá:
- Max-Heap: ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶®‡ßã‡¶°‡ßá‡¶∞ ‡¶Æ‡¶æ‡¶® ‡¶§‡¶æ‡¶∞ ‡¶∏‡¶®‡ßç‡¶§‡¶æ‡¶®‡ßá‡¶∞ ‡¶Æ‡¶æ‡¶®‡ßá‡¶∞ ‡¶ö‡ßá‡ßü‡ßá ‡¶¨‡ßú‡•§
- Min-Heap: ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶®‡ßã‡¶°‡ßá‡¶∞ ‡¶Æ‡¶æ‡¶® ‡¶§‡¶æ‡¶∞ ‡¶∏‡¶®‡ßç‡¶§‡¶æ‡¶®‡ßá‡¶∞ ‡¶Æ‡¶æ‡¶®‡ßá‡¶∞ ‡¶ö‡ßá‡ßü‡ßá ‡¶õ‡ßã‡¶ü‡•§
- 
```cpp
 
#include <iostream>
#include <queue>
using namespace std;

int main() {
    priority_queue<int> maxHeap;
    maxHeap.push(10);
    maxHeap.push(20);
    maxHeap.push(15);
    
    cout << "Max Heap Top: " << maxHeap.top() << endl;  // 20
    return 0;
}
```

######‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ: ‡¶è‡¶ñ‡¶æ‡¶®‡ßá Max-Heap ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá, ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶∏‡¶∞‡ßç‡¶¨‡ßã‡¶ö‡ßç‡¶ö ‡¶Æ‡¶æ‡¶® (20) ‡¶∂‡ßÄ‡¶∞‡ßç‡¶∑‡ßá ‡¶•‡¶æ‡¶ï‡ßá‡•§

### 3. ‡¶π‡ßç‡¶Ø‡¶æ‡¶∂‡¶ø‡¶Ç (Hashing)
- Hash Table (‡¶π‡ßç‡¶Ø‡¶æ‡¶∂ ‡¶ü‡ßá‡¶¨‡¶ø‡¶≤):
- Hash Table ‡¶è‡¶ï‡¶ü‡¶ø ‡¶°‡¶æ‡¶ü‡¶æ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ ‡¶Ø‡¶æ ‡¶ï‡ßÄ-‡¶¨‡ßü‡¶∏‡ßÄ ‡¶Æ‡¶æ‡¶® ‡¶∏‡¶Ç‡¶∞‡¶ï‡ßç‡¶∑‡¶£ ‡¶ï‡¶∞‡ßá ‡¶è‡¶¨‡¶Ç ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ï‡ßç‡¶∏‡ßá‡¶∏‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶è‡¶ï‡¶ü‡¶ø ‡¶π‡ßç‡¶Ø‡¶æ‡¶∂ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá‡•§
- 
```cpp
 
#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    unordered_map<string, int> hashTable;
    hashTable["apple"] = 5;
    hashTable["banana"] = 3;
    
    cout << "Apple count: " << hashTable["apple"] << endl;
    return 0;
}
```

###### ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ: ‡¶è‡¶ñ‡¶æ‡¶®‡ßá unordered_map ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá ‡¶Ø‡¶æ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶π‡ßç‡¶Ø‡¶æ‡¶∂ ‡¶ü‡ßá‡¶¨‡¶ø‡¶≤ ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá‡•§

4. ‡¶¨‡¶ø‡¶ü ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡¶ø‡¶™‡ßÅ‡¶≤‡ßá‡¶∂‡¶® (Bit Manipulation)
AND, OR, XOR Operations (‡¶è‡¶®‡ßç‡¶°, ‡¶Ö‡¶∞, ‡¶è‡¶ï‡ßç‡¶∏‡¶Ö‡¶∞ ‡¶Ö‡¶™‡¶æ‡¶∞‡ßá‡¶∂‡¶®):
```cpp

#include <iostream>
using namespace std;

int main() {
    int a = 5; // 0101
    int b = 3; // 0011
    cout << "a & b: " << (a & b) << endl;  // AND operation
    cout << "a | b: " << (a | b) << endl;  // OR operation
    cout << "a ^ b: " << (a ^ b) << endl;  // XOR operation
    return 0;
}
```

###### ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ: ‡¶è‡¶ñ‡¶æ‡¶®‡ßá AND, OR, ‡¶è‡¶¨‡¶Ç XOR ‡¶Ö‡¶™‡¶æ‡¶∞‡ßá‡¶∂‡¶®‡¶ó‡ßÅ‡¶≤‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§

### 5. Disjoint Set (Union-Find)

- Union by Rank (‡¶á‡¶â‡¶®‡¶ø‡ßü‡¶® ‡¶¨‡¶æ‡¶á ‡¶∞‡ßç‡¶Ø‡¶æ‡¶Ç‡¶ï):
- Union-Find ‡¶°‡¶æ‡¶ü‡¶æ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞‡¶ü‡¶ø ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶®‡¶ó‡ßÅ‡¶≤‡¶ø‡¶∞ ‡¶ó‡ßç‡¶∞‡ßÅ‡¶™‡¶ø‡¶Ç‡ßü‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü, ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶¶‡ßÅ‡¶ü‡¶ø ‡¶∏‡ßá‡¶ü‡ßá‡¶∞ ‡¶á‡¶â‡¶®‡¶ø‡ßü‡¶® ‡¶ï‡¶∞‡¶æ ‡¶è‡¶¨‡¶Ç ‡¶§‡¶æ‡¶¶‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶ï‡ßã‡¶®‡¶ü‡¶ø ‡¶¨‡¶°‡¶º ‡¶§‡¶æ ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡•§

```cpp
#include <iostream>
#include <vector>
using namespace std;

class DisjointSet {
public:
    vector<int> parent, rank;
    
    DisjointSet(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
        }
    }
    
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        
        if (rootX != rootY) {
            if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else {
                parent[rootY] = rootX;
                ++rank[rootX];
            }
        }
    }
};

int main() {
    DisjointSet ds(5);
    ds.unite(0, 1);
    ds.unite(1, 2);
    cout << "Find(0): " << ds.find(0) << endl; // 0
    cout << "Find(2): " << ds.find(2) << endl; // 0
    return 0;
}
```

###### ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ: ‡¶è‡¶ñ‡¶æ‡¶®‡ßá Union-Find ‡¶°‡¶æ‡¶ü‡¶æ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá ‡¶Ø‡¶æ‡¶§‡ßá ‡¶¶‡ßÅ‡¶ü‡¶ø ‡¶∏‡ßá‡¶ü ‡¶è‡¶ï‡¶§‡ßç‡¶∞‡¶ø‡¶§ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü ‡¶è‡¶¨‡¶Ç ‡¶§‡¶æ‡¶¶‡ßá‡¶∞ ‡¶∞‡ßÅ‡¶ü ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡•§
 
