<div align="center">
  <img height="150" src="https://www.tutorialspoint.com/data_structures_algorithms/images/linear_search.gif"  />
</div>

###

<h1 align="center">C  C++ DSA  Algorithms</h1>
 
###

**Algorithm Complexities - Notes**

## **Algorithm Complexity Table**
<h6> 
  
| **Algorithm Type** | **Algorithm**       | **Best Case** | **Average Case** | **Worst Case** | **Space Complexity** |
|--------------------|---------------------|--------------|----------------|--------------|----------------|
| **Searching**      | Linear Search       | O(1)         | O(n)           | O(n)         | O(1)           |
|                    | Binary Search       | O(1)         | O(log n)       | O(log n)     | O(1)           |
| **Sorting**        | Bubble Sort         | O(n)         | O(n┬▓)          | O(n┬▓)        | O(1)           |
|                    | Selection Sort      | O(n┬▓)        | O(n┬▓)          | O(n┬▓)        | O(1)           |
|                    | Insertion Sort      | O(n)         | O(n┬▓)          | O(n┬▓)        | O(1)           |
|                    | Merge Sort          | O(n log n)   | O(n log n)     | O(n log n)   | O(n)           |
|                    | Quick Sort          | O(n log n)   | O(n log n)     | O(n┬▓)        | O(log n)       |
|                    | Heap Sort           | O(n log n)   | O(n log n)     | O(n log n)   | O(1)           |
|                    | Counting Sort       | O(n + k)     | O(n + k)       | O(n + k)     | O(k)           |
|                    | Radix Sort          | O(nk)        | O(nk)          | O(nk)        | O(n + k)       |
|                    | Bucket Sort         | O(n + k)     | O(n + k)       | O(n┬▓)        | O(n)           |
| **Graph**          | BFS (Adj. List)     | O(V + E)     | O(V + E)       | O(V + E)     | O(V)           |
|                    | DFS (Adj. List)     | O(V + E)     | O(V + E)       | O(V + E)     | O(V)           |
|                    | Dijkstra (Heap)     | O((V + E) log V) | O((V + E) log V) | O((V + E) log V) | O(V + E)       |
|                    | Bellman-Ford        | O(VE)        | O(VE)          | O(VE)        | O(V)           |
|                    | Floyd-Warshall      | O(n┬│)        | O(n┬│)          | O(n┬│)        | O(n┬▓)          |
|                    | KruskalтАЩs Algorithm | O(E log E)   | O(E log E)     | O(E log E)   | O(E + V)       |
|                    | PrimтАЩs Algorithm    | O((V + E) log V) | O((V + E) log V) | O((V + E) log V) | O(V┬▓) or O(E + V) with heap |

</h6>


---

### **Conclusion**
Understanding time and space complexity is crucial for optimizing algorithms. Always consider the input size and constraints to choose the most efficient algorithm. 

Let me know if you need any modifications or explanations! ЁЯЪА


## Algorithm and Data Structure (DSA) - Study Guide

<h6> 

## Content
1. [ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо ржмрж┐рж╢рзНрж▓рзЗрж╖ржг](#ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо-ржмрж┐рж╢рзНрж▓рзЗрж╖ржг-algorithm-analysis)
2. [рж╕рж╛рж░рзНржЪрж┐ржВ ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо](#рж╕рж╛рж░рзНржЪрж┐ржВ-ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо-searching-algorithms)
3. [рж╕рж░рзНржЯрж┐ржВ ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо](#рж╕рж░рзНржЯрж┐ржВ-ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо-sorting-algorithms)
4. [ржЧрзНрж░рж╛ржл ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо](#ржЧрзНрж░рж╛ржл-ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо-graph-algorithms)
5. [ржЧрзНрж░рж┐ржбрж┐ ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо](#ржЧрзНрж░рж┐ржбрж┐-ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо-greedy-algorithms)
6. [ржбрж╛рзЯржирж╛ржорж┐ржХ ржкрзНрж░рзЛржЧрзНрж░рж╛ржорж┐ржВ](#ржбрж╛рзЯржирж╛ржорж┐ржХ-ржкрзНрж░рзЛржЧрзНрж░рж╛ржорж┐ржВ-dynamic-programming)
7. [ржбрж┐ржнрж╛ржЗржб ржЕрзНржпрж╛ржирзНржб ржХржиржХрзЛрзЯрж╛рж░](#ржбрж┐ржнрж╛ржЗржб-ржЕрзНржпрж╛ржирзНржб-ржХржиржХрзЛрзЯрж╛рж░-divide-and-conquer)
8. [ржмрзНржпрж╛ржХржЯрзНрж░рзНржпрж╛ржХрж┐ржВ](#ржмрзНржпрж╛ржХржЯрзНрж░рзНржпрж╛ржХрж┐ржВ-backtracking)
9. [ржмрж┐ржЯ ржорзНржпрж╛ржирж┐ржкрзБрж▓рзЗрж╢ржи](#ржмрж┐ржЯ-ржорзНржпрж╛ржирж┐ржкрзБрж▓рзЗрж╢ржи-bit-manipulation)
10. [ржЙржирзНржиржд ржбрж╛ржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░](#ржЙржирзНржиржд-ржбрж╛ржЯрж╛-рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░-advanced-data-structures)
11. [рж╕рзНржЯрзНрж░рж┐ржВ ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо](#рж╕рзНржЯрзНрж░рж┐ржВ-ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо-string-algorithms)
12. [ржХржорзНржкрж┐ржЙржЯрзЗрж╢ржирж╛рж▓ ржЬрж┐ржУржорзЗржЯрзНрж░рж┐](#ржХржорзНржкрж┐ржЙржЯрзЗрж╢ржирж╛рж▓-ржЬрж┐ржУржорзЗржЯрзНрж░рж┐-computational-geometry)

</h6>
---

### ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо ржмрж┐рж╢рзНрж▓рзЗрж╖ржг (Algorithm Analysis)

- **ржЯрж╛ржЗржо ржХржоржкрзНрж▓рзЗржХрзНрж╕рж┐ржЯрж┐**: ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржорзЗрж░ рж░рж╛ржи ржЯрж╛ржЗржо ржирж┐рж░рзНржзрж╛рж░ржг ржХрж░рж╛рж░ ржЬржирзНржп ржмрзНржпржмрж╣рзГржд рж╣рзЯред ржПржЯрж┐ **Big-O**, **Big-╬й**, ржПржмржВ **Big-╬Ш** ржжрзНржмрж╛рж░рж╛ ржкрзНрж░ржХрж╛рж╢ ржХрж░рж╛ рж╣рзЯред
- **рж╕рзНржкрзЗрж╕ ржХржоржкрзНрж▓рзЗржХрзНрж╕рж┐ржЯрж┐**: ржорзЗржорзЛрж░рж┐ ржмрзНржпржмрж╣рж╛рж░рзЗрж░ ржкрж░рж┐ржорж╛ржг ржмрзЛржЭрж╛рзЯред
- **ржмрзЗрж╕рзНржЯ, ржПржнрж╛рж░рзЗржЬ**, ржУрзЯрж╛рж░рзНрж╕рзНржЯ ржХрзЗрж╕: ржЗржиржкрзБржЯ ржнрзЗржжрзЗ ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржорзЗрж░ ржкрж╛рж░ржлрж░ржорзЗржирзНрж╕ ржХрзЗржоржи рж╣ржмрзЗ рждрж╛ ржмрж┐рж╢рзНрж▓рзЗрж╖ржг ржХрж░рж╛ рж╣рзЯред
- **Amortized Analysis**: ржХрж┐ржЫрзБ ржЕржкрж╛рж░рзЗрж╢ржирзЗрж░ ржЧрзЬ ржХржоржкрзНрж▓рзЗржХрзНрж╕рж┐ржЯрж┐ ржирж┐рж░рзНржзрж╛рж░ржг ржХрж░рж╛ред

---

### рж╕рж╛рж░рзНржЪрж┐ржВ ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо (Searching Algorithms)

- **Linear Search**: ***`O(n)`*** тАУ ржПржХржЯрж┐ ржПрж▓рж┐ржорзЗржирзНржЯ ржЦрзЛржБржЬрж╛рж░ ржЬржирзНржп ржкрзБрж░рзЛ рж▓рж┐рж╕рзНржЯрзЗрж░ ржкрзНрж░рждрж┐ржЯрж┐ ржЖржЗржЯрзЗржо ржкрж░рзАржХрзНрж╖рж╛ ржХрж░рж╛ рж╣рзЯред
- **Binary Search**: ***`O(log n)`*** тАУ ржЗржиржкрзБржЯ рж▓рж┐рж╕рзНржЯ ржпржжрж┐ рж╕рж░рзНржЯрзЗржб ржерж╛ржХрзЗ рждржмрзЗ ржмрж╛ржЗржирж╛рж░рж┐ рж╕рж╛рж░рзНржЪ ржПрж▓рж┐ржорзЗржирзНржЯ ржЦрзЛржБржЬрж╛рж░ ржЬржирзНржп ржжрзНрж░рзБрждрждрж░ ржкржжрзНржзрждрж┐ред
- **Ternary Search**: ***`O(log n)`*** тАУ рждрж┐ржи ржнрж╛ржЧрзЗ ржнрж╛ржЧ ржХрж░рзЗ ржЕржирзБрж╕ржирзНржзрж╛ржи ржХрж░рж╛ рж╣рзЯред
- **Interpolation Search**: ***`O(log log n)`*** тАУ Binary Search ржПрж░ ржЙржирзНржиржд рж╕ржВрж╕рзНржХрж░ржгред
- **Exponential Search**: ***`O(log n)`*** тАУ ржПрж▓рж┐ржорзЗржирзНржЯрзЗрж░ ржЕржмрж╕рзНржерж╛ржи ржЕржЬрж╛ржирж╛ рж╣рж▓рзЗ ржПржЯрж┐ ржмрзНржпржмрж╣рж╛рж░ рж╣рзЯред

---

### рж╕рж░рзНржЯрж┐ржВ ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо (Sorting Algorithms)

- **Bubble Sort**: ***`O(n^2)`*** тАУ ржПржХрзЗрж░ ржкрж░ ржПржХ рж╕ржирзНржирж┐ржмрзЗрж╢рж┐ржд ржЙржкрж╛ржжрж╛ржиржЧрзБрж▓рзЛ рждрзБрж▓ржирж╛ ржХрж░рзЗ рж╕рж░рзНржЯ ржХрж░рж╛ рж╣рзЯред
- **Selection Sort**: ***`O(n^2)`*** тАУ ржПржХржЯрж┐ ржЫрзЛржЯрждржо ржЙржкрж╛ржжрж╛ржиржХрзЗ ржирж┐рж░рзНржмрж╛ржЪржи ржХрж░рзЗ рж╕рзЗржЯрж┐ рж╕ржарж┐ржХ рж╕рзНржерж╛ржирзЗ рж░рж╛ржЦрж╛рж░ ржкржжрзНржзрждрж┐ред
- **Insertion Sort**: ***`O(n^2)`*** тАУ ржПрж▓рж┐ржорзЗржирзНржЯржЧрзБрж▓рж┐ржХрзЗ ржПржХржЯрж┐ ржПржХржЯрж┐ ржХрж░рзЗ ржЗржирж╕рж╛рж░рзНржЯ ржХрж░рзЗ ржЗржиржкрзБржЯ ржЕрзНржпрж╛рж░рзЗ рж╕рж░рзНржЯ ржХрж░рж╛ рж╣рзЯред
- **Merge Sort**: ***`O(n log n)`*** тАУ ржмрж┐ржнрж╛ржЬржи ржПржмржВ ржЬржпрж╝рзЗржирж┐ржВ ржкржжрзНржзрждрж┐ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржПрж▓рж┐ржорзЗржирзНржЯ рж╕рж╛ржЬрж╛ржирзЛ рж╣рзЯред
- **Quick Sort**: ***`O(n log n)`*** тАУ ржкрж┐ржнржЯ ржПрж▓рж┐ржорзЗржирзНржЯ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржжрзНрж░рзБржд рж╕рж░рзНржЯрж┐ржВ ржкржжрзНржзрждрж┐ред
- **Heap Sort**: ***`O(n log n)`*** тАУ ржПржХржЯрж┐ рж╣рж┐ржк ржбрж╛ржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржПрж▓рж┐ржорзЗржирзНржЯ рж╕рж░рзНржЯ ржХрж░рж╛ рж╣рзЯред

---

### ржЧрзНрж░рж╛ржл ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо (Graph Algorithms)

- **DFS (Depth First Search)**: ржПржХржЯрж┐ ржЧрзНрж░рж╛ржлрзЗрж░ ржоржзрзНржпрзЗ ржЧржнрзАрж░рждрж╛рж░ ржнрж┐рждрзНрждрж┐рждрзЗ ржЕржирзБрж╕ржирзНржзрж╛ржи ржХрж░рж╛ рж╣рзЯред
- **BFS (Breadth First Search)**: ржПржХржЯрж┐ ржЧрзНрж░рж╛ржлрзЗрж░ ржоржзрзНржпрзЗ ржкрзНрж░рж╕рзНржерзЗрж░ ржнрж┐рждрзНрждрж┐рждрзЗ ржЕржирзБрж╕ржирзНржзрж╛ржи ржХрж░рж╛ рж╣рзЯред
- **Dijkstra's Algorithm**: рж╕рж░рзНржмржирж┐ржорзНржи ржжрзВрж░рждрзНржмрзЗрж░ ржкржерзЗ ржпрж╛ржУрзЯрж╛рж░ ржЬржирзНржп ржмрзНржпржмрж╣рзГржд ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржоред
- **Bellman-Ford Algorithm**: ржирзЗрждрж┐ржмрж╛ржЪржХ ржУрзЯрзЗржЯ рж╕рж╣ рж╕рж░рзНржмржирж┐ржорзНржи ржкрже ржирж┐рж░рзНржзрж╛рж░ржгрзЗрж░ ржЬржирзНржп ржмрзНржпржмрж╣рзГржд рж╣рзЯред
- **Floyd-Warshall Algorithm**: рж╕ржорж╕рзНржд ржжржорзНржкрждрж┐ ржирзЛржбрзЗрж░ ржоржзрзНржпрзЗ рж╕рж░рзНржмржирж┐ржорзНржи ржкрже ржЦрзЛржБржЬрж╛рж░ ржЬржирзНржп ржмрзНржпржмрж╣рзГржд рж╣рзЯред

---

### ржЧрзНрж░рж┐ржбрж┐ ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо (Greedy Algorithms)

- **Activity Selection Problem**: ржирж┐рж░рзНржмрж╛ржЪрж┐ржд ржХрж░рзНржоржХрж╛ржгрзНржбрзЗрж░ ржЬржирзНржп рж╕рж░рзНржмрж╛ржзрж┐ржХ рж╕ржорзЯрзЗ ржХрж╛ржЬрзЗ рж▓рж╛ржЧрж╛ржирзЛрж░ ржХрзМрж╢рж▓ред
- **Huffman Coding**: ржбрж╛ржЯрж╛ рж╕ржВржХрзЛржЪржи ржкржжрзНржзрждрж┐ ржпрзЗржЦрж╛ржирзЗ рж╣рж╛ржлржорзНржпрж╛ржи ржЯрзНрж░рж┐ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ рж╣рзЯред
- **Fractional Knapsack**: ржкржгрзНржпрзЗрж░ ржнрж░ ржЕржирзБржпрж╛рзЯрзА рж╕рж░рзНржмрж╛ржзрж┐ржХ рж▓рж╛ржн ржЕрж░рзНржЬржи ржХрж░рждрзЗ ржЧрзНрж░рж┐ржбрж┐ ржкржжрзНржзрждрж┐ ржмрзНржпржмрж╣рзГржд рж╣рзЯред
- **Prim's Algorithm**: ржорж┐ржирж┐ржорж╛ржо рж╕рзНржкрзНржпрж╛ржирж┐ржВ ржЯрзНрж░рж┐ рждрзИрж░рж┐ ржХрж░рж╛рж░ ржЬржирзНржп ржмрзНржпржмрж╣рзГрждред

---

### ржбрж╛рзЯржирж╛ржорж┐ржХ ржкрзНрж░рзЛржЧрзНрж░рж╛ржорж┐ржВ (Dynamic Programming)

- **Fibonacci Sequence**: **O(n)** рж╕ржорзЯрзЗрж░ ржоржзрзНржпрзЗ ржлрж┐ржмрзЛржирж╛ржЪрзНржЪрж┐ рж╕рж┐рж░рж┐ржЬ ржмрзЗрж░ ржХрж░рж╛ред
- **Knapsack Problem**: ржПржХржЯрж┐ ржмрж╕рзНрждрзБ ржирж┐рж░рзНржмрж╛ржЪржи ржХрж░рж╛рж░ ржЬржирзНржп рж╕рж░рзНржмрж╛ржзрж┐ржХ ржорзВрж▓рзНржп ржирж┐рж░рзНржзрж╛рж░ржг ржХрж░рждрзЗ ржмрзНржпржмрж╣рзГржд рж╣рзЯред
- **Longest Common Subsequence**: ржжрзБржЯрж┐ рж╕рзНржЯрзНрж░рж┐ржВрзЯрзЗрж░ ржоржзрзНржпрзЗ рж╕ржмржЪрзЗрзЯрзЗ ржмрзЬ рж╕рж╛ржзрж╛рж░ржг рж╕рж╛ржмрж╕рж┐ржХрзЛрзЯрзЗржирзНрж╕ ржирж┐рж░рзНржзрж╛рж░ржг ржХрж░рж╛ред
- **Longest Increasing Subsequence**: ржПржХржзрж╛ржк ржмрж╛рзЬрж╛ржирзЛ ржЙржкрж╛ржжрж╛ржиржЧрзБрж▓рзЛрж░ ржоржзрзНржпрзЗ рж╕ржмржЪрзЗрзЯрзЗ ржмрзЬ ржЙржкрж╕рзЗржЯ ржмрзЗрж░ ржХрж░рж╛ред

---

### ржбрж┐ржнрж╛ржЗржб ржЕрзНржпрж╛ржирзНржб ржХржиржХрзЛрзЯрж╛рж░ (Divide and Conquer)

- **Merge Sort**: ржЙржкрж░рзЗрж░ ржорждрзЛ, ржбрж┐ржнрж╛ржЗржб ржЕрзНржпрж╛ржирзНржб ржХржиржХрзЛрзЯрж╛рж░ ржкржжрзНржзрждрж┐ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ рж╕рж░рзНржЯрж┐ржВ ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржоред
- **Quick Sort**: ржЗржиржкрзБржЯ ржбрж╛ржЯрж╛ ржнрж╛ржЧ ржХрж░рзЗ ржжрзНрж░рзБржд рж╕рж░рзНржЯрж┐ржВ ржХрж░рж╛рж░ ржЬржирзНржп ржмрзНржпржмрж╣рзГрждред
- **Binary Search**: ржЗржиржкрзБржЯ ржбрж╛ржЯрж╛ ржнрж╛ржЧ ржХрж░рзЗ ржжрзНрж░рзБржд ржЕржирзБрж╕ржирзНржзрж╛ржи ржХрж░рж╛ рж╣рзЯред

---

### ржмрзНржпрж╛ржХржЯрзНрж░рзНржпрж╛ржХрж┐ржВ (Backtracking)

- **N-Queens Problem**: ржПржХржЯрж┐ ржПржи-ржХрзБрзЯрж┐ржирзНрж╕рзЗрж░ рж╕ржорж╕рзНржпрж╛ рж╕ржорж╛ржзрж╛ржи ржХрж░рж╛ ржпрзЗржЦрж╛ржирзЗ ржХрзБржЗржиржжрзЗрж░ ржкрж░рж╕рзНржкрж░ржХрзЗ ржЖржХрзНрж░ржоржг ржирж╛ ржХрж░рзЗ ржмрж╕рж╛ржирзЛ рж╣рзЯред
- **Subset Sum Problem**: ржПржХржЯрж┐ рж╕рж╛ржмрж╕рзЗржЯ ржЦрзЛржБржЬрж╛ ржпрж╛ ржПржХржЯрж┐ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ рж╕ржВржЦрзНржпрж╛ ржпрзЛржЧржлрж▓ рждрзИрж░рж┐ ржХрж░рзЗред
- **Sudoku Solver**: ржПржХржЯрж┐ рж╕рзБржжрзЛржХрзБ рж╕ржорж╕рзНржпрж╛ рж╕ржорж╛ржзрж╛ржи ржХрж░рж╛ред

---

### ржмрж┐ржЯ ржорзНржпрж╛ржирж┐ржкрзБрж▓рзЗрж╢ржи (Bit Manipulation)

- **Bitwise AND, OR, XOR**: ржмрж┐ржЯржУрзЯрж╛ржЗржЬ ржЕржкрж╛рж░рзЗрж╢ржи ржХрж░рж╛рж░ ржкржжрзНржзрждрж┐ред
- **Checking if a number is power of 2**: ржПржХржЯрж┐ рж╕ржВржЦрзНржпрж╛ рзи ржПрж░ рж╢ржХрзНрждрж┐ ржХрж┐ржирж╛ рждрж╛ ржЪрзЗржХ ржХрж░рж╛ред
- **Counting set bits**: ржПржХржЯрж┐ рж╕ржВржЦрзНржпрж╛рж░ рж╕рзЗржЯ ржмрж┐ржЯ ржЧржгржирж╛ ржХрж░рж╛ред

---

### ржЙржирзНржиржд ржбрж╛ржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░ (Advanced Data Structures)

- **Trie**: ржПржХржЯрж┐ ржЯрзНрж░рж┐ ржбрж╛ржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░ ржпрж╛ рж╕рзНржЯрзНрж░рж┐ржВ ржЕржирзБрж╕ржирзНржзрж╛ржирзЗ ржмрзНржпржмрж╣рзГржд рж╣рзЯред
- **Segment Tree**: ржПржХржЯрж┐ ржЕрзНржпрж╛рж░рзЗ ржкрж░рж┐рж╕рж░рзЗрж░ ржЬржирзНржп ржжрзНрж░рзБржд ржХрзБржЗрж░рж┐ ржПржмржВ ржЖржкржбрзЗржЯ ржЕржкрж╛рж░рзЗрж╢ржи ржХрж░рж╛рж░ ржЬржирзНржп ржмрзНржпржмрж╣рзГржд рж╣рзЯред
- **Fenwick Tree (Binary Indexed Tree)**: ржПржХржЯрж┐ ржбрж╛ржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░ ржпрж╛ ржХрзБржЗрж░рж┐ ржУ ржЖржкржбрзЗржЯ ржЕржкрж╛рж░рзЗрж╢ржи ржХрж╛рж░рзНржпржХрж░ржнрж╛ржмрзЗ рж╕ржорзНржкрж╛ржжржи ржХрж░рждрзЗ ржмрзНржпржмрж╣рзГржд рж╣рзЯред
- **Disjoint Set (Union-Find)**: ржПржХржЯрж┐ ржбрж╛ржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░ ржпрж╛ ржЙржкрж╛ржжрж╛ржиржЧрзБрж▓рзЛржХрзЗ рж╕ржорж┐рждрж┐ ржмрж╛ ржХрзНрж▓рж╛рж╕рзЗ ржнрж╛ржЧ ржХрж░рждрзЗ ржмрзНржпржмрж╣рзГржд рж╣рзЯред

---

### рж╕рзНржЯрзНрж░рж┐ржВ ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо (String Algorithms)

- **Naive Pattern Searching**: ржПржХржЯрж┐ рж╕рзНржЯрзНрж░рж┐ржВрзЯрзЗрж░ ржоржзрзНржпрзЗ ржкрзНржпрж╛ржЯрж╛рж░рзНржи ржЦрзЛржБржЬрж╛рж░ рж╕рж╛ржзрж╛рж░ржг ржкржжрзНржзрждрж┐ред
- **KMP (Knuth-Morris-Pratt)**: ржжрзНрж░рзБржд ржкрзНржпрж╛ржЯрж╛рж░рзНржи ржЕржирзБрж╕ржирзНржзрж╛ржирзЗрж░ ржЬржирзНржп ржПржХржЯрж┐ ржЙржирзНржиржд ржкржжрзНржзрждрж┐ред
- **Rabin-Karp**: рж╣рзНржпрж╛рж╢рж┐ржВ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ рж╕рзНржЯрзНрж░рж┐ржВ ржкрзНржпрж╛ржЯрж╛рж░рзНржи ржЕржирзБрж╕ржирзНржзрж╛ржи ржХрж░рж╛ред
- **Z Algorithm**: рж╕рзНржЯрзНрж░рж┐ржВ ржкрзНржпрж╛ржЯрж╛рж░рзНржи ржЦрзЛржБржЬрж╛рж░ ржЬржирзНржп ржПржХржЯрж┐ рж╢ржХрзНрждрж┐рж╢рж╛рж▓рзА ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржоред

---

### ржХржорзНржкрж┐ржЙржЯрзЗрж╢ржирж╛рж▓ ржЬрж┐ржУржорзЗржЯрзНрж░рж┐ (Computational Geometry)

- **Convex Hull**: ржПржХржЯрж┐ рж╕ржирзНржирж┐ржмрзЗрж╢рж┐ржд ржкрзЯрзЗржирзНржЯрж╕рзЗрж░ ржоржзрзНржпрзЗ рж╕рж░рзНржмржирж┐ржорзНржи ржЖржХрж╛рж░рзЗрж░ ржмрж╛ржЙржирзНржбрж┐ржВ рж╣рж╛рж▓рзНрж▓ рждрзИрж░рж┐ ржХрж░рж╛ред
- **Line Intersection**: ржжрзБржЯрж┐ рж▓рж╛ржЗржи ржПржХрзЗ ржЕржкрж░ржХрзЗ ржЫрзЗржж ржХрж░рзЗ ржХрж┐ржирж╛ рждрж╛ ржпрж╛ржЪрж╛ржЗ ржХрж░рж╛ред
- **Point in Polygon**: ржПржХржЯрж┐ ржкрзЯрзЗржирзНржЯ ржПржХржЯрж┐ ржмрж╣рзБржкржжрзА (polygon) ржПрж░ ржоржзрзНржпрзЗ ржЕржмрж╕рзНржерж┐ржд ржХрж┐ржирж╛ рждрж╛ ржкрж░рзАржХрзНрж╖рж╛ ржХрж░рж╛ред

---

<br>
<br>
<br>





















## Here's a detailed explanation of the Data Structures and Algorithms (DSA) topics in C++ with examples and explanations in Bangla:

### 1. ржмрзЗрж╕рж┐ржХ ржбрж╛ржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░ (Basic Data Structures)
#### Array (ржПрж░рзЗ):
Array рж╣рж▓ ржПржХржЯрж┐ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ ржЖржХрж╛рж░рзЗрж░ ржбрж╛ржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░ ржпрзЗржЦрж╛ржирзЗ ржПржХрж╕рж╛ржерзЗ ржПржХрж╛ржзрж┐ржХ ржбрж╛ржЯрж╛ рж╕рзНржЯрзЛрж░ ржХрж░рж╛ ржпрж╛рзЯред

```cpp
#include <iostream>
using namespace std;

int main() {
    int arr[] = {1, 2, 3, 4, 5};  // Array Declaration
    cout << "Array Element at index 0: " << arr[0] << endl;
    return 0;
}

```

###### ржмрзНржпрж╛ржЦрзНржпрж╛: ржПржЦрж╛ржирзЗ, ржПржХржЯрж┐ ржЕрзНржпрж╛рж░рзЗ arr[] рждрзИрж░рж┐ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ ржпрж╛ 5ржЯрж┐ ржЗржирзНржЯрж┐ржЬрж╛рж░ ржзрж╛рж░ржг ржХрж░рзЗред

### Linked List (рж▓рж┐ржЩрзНржХржб рж▓рж┐рж╕рзНржЯ):
##### Linked List ржПржХржЯрж┐ рж▓рж┐ржирж┐рзЯрж╛рж░ ржбрж╛ржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░, ржпрзЗржЦрж╛ржирзЗ ржкрзНрж░рждрж┐ржЯрж┐ ржирзЛржбрзЗ ржбрж╛ржЯрж╛ ржерж╛ржХрзЗ ржПржмржВ ржкрж░ржмрж░рзНрждрзА ржирзЛржбрзЗрж░ ржкрзЯрзЗржирзНржЯрж╛рж░ ржерж╛ржХрзЗред
Singly Linked List (рж╕рж┐ржЩрзНржЧрж▓рж┐ рж▓рж┐ржЩрзНржХржб рж▓рж┐рж╕рзНржЯ):

```cpp

#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

int main() {
    Node* head = new Node(); // Create first node
    head->data = 1;
    head->next = nullptr;

    Node* second = new Node(); // Create second node
    second->data = 2;
    second->next = nullptr;
    
    head->next = second; // Link the first node to second node
    
    cout << "First node data: " << head->data << endl;
    cout << "Second node data: " << second->data << endl;

    return 0;
}
```
###### ржмрзНржпрж╛ржЦрзНржпрж╛: ржПржЦрж╛ржирзЗ ржПржХржЯрж┐ рж╕рж┐ржЩрзНржЧрж▓рж┐ рж▓рж┐ржЩрзНржХржб рж▓рж┐рж╕рзНржЯ рждрзИрж░рж┐ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ ржпрзЗржЦрж╛ржирзЗ ржжрзБржЯрж┐ ржирзЛржб рж╕ржВржпрзБржХрзНржд рж░рзЯрзЗржЫрзЗред

##### Doubly Linked List (ржбрж╛ржмрж▓рж┐ рж▓рж┐ржЩрзНржХржб рж▓рж┐рж╕рзНржЯ):

```
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* prev;
    Node* next;
};

int main() {
    Node* head = new Node(); // Create first node
    head->data = 1;
    head->prev = nullptr;
    head->next = nullptr;
    
    Node* second = new Node(); // Create second node
    second->data = 2;
    second->prev = head;
    second->next = nullptr;
    
    head->next = second; // Link the first node to second node
    
    cout << "First node data: " << head->data << endl;
    cout << "Second node data: " << second->data << endl;

    return 0;
}
```

###### ржмрзНржпрж╛ржЦрзНржпрж╛: ржПржЦрж╛ржирзЗ, Doubly Linked List рждрзИрж░рж┐ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ, ржпрзЗржЦрж╛ржирзЗ ржкрзНрж░рждрж┐ржЯрж┐ ржирзЛржбрзЗ prev ржПржмржВ next ржкрзЯрзЗржирзНржЯрж╛рж░ рж░рзЯрзЗржЫрзЗред

##### Circular Linked List (рж╕рж╛рж░рзНржХрзБрж▓рж╛рж░ рж▓рж┐ржЩрзНржХржб рж▓рж┐рж╕рзНржЯ):
```cpp
 
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

int main() {
    Node* head = new Node();
    head->data = 1;
    head->next = head;  // Circular Link
    
    cout << "Head node data: " << head->data << endl;

    return 0;
}
```

ржмрзНржпрж╛ржЦрзНржпрж╛: ржПржЦрж╛ржирзЗ Circular Linked List рждрзИрж░рж┐ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ, ржпрзЗржЦрж╛ржирзЗ рж▓рж╛рж╕рзНржЯ ржирзЛржб ржЖржмрж╛рж░ ржкрзНрж░ржержо ржирзЛржбрзЗ рж╕ржВржпрзБржХрзНржд ржерж╛ржХрзЗред

### Stack (рж╕рзНржЯрзНржпрж╛ржХ):
- Stack рж╣рж▓ ржПржХржЯрж┐ ржбрж╛ржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░ ржпрж╛ LIFO (Last In First Out) ржирзАрждрж┐ ржЕржирзБрж╕рж░ржг ржХрж░рзЗред ржПрж░ ржоржзрзНржпрзЗ рждрж┐ржиржЯрж┐ ржорзВрж▓ ржЕржкрж╛рж░рзЗрж╢ржи рж░рзЯрзЗржЫрзЗ:
- Push Operation: ржПржХржЯрж┐ ржЙржкрж╛ржжрж╛ржи рж╕рзНржЯрзНржпрж╛ржХрзЗ ржкрзНрж░ржмрзЗрж╢ ржХрж░рж╛ред
- Pop Operation: рж╕рж░рзНржмрж╢рзЗрж╖ ржЙржкрж╛ржжрж╛ржиржЯрж┐ рж╕рзНржЯрзНржпрж╛ржХ ржерзЗржХрзЗ ржмрзЗрж░ ржХрж░рж╛ред
- Peek/Top Operation: рж╕рзНржЯрзНржпрж╛ржХрзЗрж░ рж╢рзАрж░рзНрж╖ ржЙржкрж╛ржжрж╛ржи ржжрзЗржЦрж╛ред

```cpp
 
#include <iostream>
#include <stack>
using namespace std;

int main() {
    stack<int> s;
    s.push(10);  // Push 10
    s.push(20);  // Push 20
    cout << "Top element: " << s.top() << endl; // Top element
    s.pop();  // Pop 20
    cout << "Top element after pop: " << s.top() << endl; // Top element after pop
    return 0;
}
```

###### ржмрзНржпрж╛ржЦрзНржпрж╛: рж╕рзНржЯрзНржпрж╛ржХрзЗ 10 ржПржмржВ 20 ржпрзЛржЧ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ ржПржмржВ ржкрж░ржмрж░рзНрждрзАрждрзЗ 20 ржХрзЗ ржкржк ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред

### Queue (ржХрж┐ржЙ):
- Queue рж╣рж▓ ржПржХржЯрж┐ ржбрж╛ржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░ ржпрж╛ FIFO (First In First Out) ржирзАрждрж┐ ржЕржирзБрж╕рж░ржг ржХрж░рзЗред
vEnqueue Operation: ржПржХржЯрж┐ ржЙржкрж╛ржжрж╛ржи ржХрж┐ржЙрждрзЗ ржкрзНрж░ржмрзЗрж╢ ржХрж░рж╛ред
- Dequeue Operation: ржкрзНрж░ржержо ржЙржкрж╛ржжрж╛ржиржЯрж┐ ржХрж┐ржЙ ржерзЗржХрзЗ ржмрзЗрж░ ржХрж░рж╛ред
- Front Operation: ржХрж┐ржЙрзЯрзЗрж░ ржкрзНрж░ржержо ржЙржкрж╛ржжрж╛ржи ржжрзЗржЦрж╛ред


```cpp
 
#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<int> q;
    q.push(10);  // Enqueue 10
    q.push(20);  // Enqueue 20
    cout << "Front element: " << q.front() << endl; // Front element
    q.pop();  // Dequeue 10
    cout << "Front element after pop: " << q.front() << endl; // Front element after pop
    return 0;
}
```
##### ржмрзНржпрж╛ржЦрзНржпрж╛: ржХрж┐ржЙрждрзЗ 10 ржПржмржВ 20 ржпрзЛржЧ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ ржПржмржВ ржкрж░ржмрж░рзНрждрзАрждрзЗ 10 ржХрзЗ ржбрж┐ржХрж┐ржЙ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред

### Deque (ржбрж┐ржХрзБ):
##### Deque рж╣рж▓ ржПржХржЯрж┐ ржбрж╛ржмрж▓-ржПржирзНржбрзЗржб ржХрж┐ржЙ, ржпрзЗржЦрж╛ржирзЗ ржЙржкрж╛ржжрж╛ржиржЧрзБрж▓рзЛ ржжрзБржЗ ржкрзНрж░рж╛ржирзНржд ржерзЗржХрзЗ ржкрзНрж░ржмрзЗрж╢ ржПржмржВ ржмрзЗрж░ рж╣рждрзЗ ржкрж╛рж░рзЗред

```cpp
 
#include <iostream>
#include <deque>
using namespace std;

int main() {
    deque<int> dq;
    dq.push_front(10); // Push 10 at front
    dq.push_back(20);  // Push 20 at back
    cout << "Front element: " << dq.front() << endl; // Front element
    cout << "Back element: " << dq.back() << endl;   // Back element
    dq.pop_front(); // Pop 10 from front
    dq.pop_back();  // Pop 20 from back
    return 0;
}
```

###### ржмрзНржпрж╛ржЦрзНржпрж╛: ржПржЦрж╛ржирзЗ Deque ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ front ржПржмржВ back ржкрзНрж░рж╛ржирзНржд ржерзЗржХрзЗ ржЙржкрж╛ржжрж╛ржи ржкрзНрж░ржмрзЗрж╢ ржПржмржВ ржмрзЗрж░ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред

### Priority Queue (ржкрзНрж░рж╛ржЗржУрж░рж┐ржЯрж┐ ржХрж┐ржЙ):
##### Priority Queue рж╣рж▓ ржПржХржЯрж┐ ржХрж┐ржЙ ржпрзЗржЦрж╛ржирзЗ ржкрзНрж░рждрж┐ржЯрж┐ ржЙржкрж╛ржжрж╛ржиржХрзЗ ржПржХржЯрж┐ priority ржжрзЗржУрзЯрж╛ рж╣рзЯ ржПржмржВ рж╕рж░рзНржмрзЛржЪрзНржЪ priority ржПрж░ ржЙржкрж╛ржжрж╛ржи ржкрзНрж░ржержорзЗ ржмрзЗрж░ рж╣рзЯред

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    priority_queue<int> pq;
    pq.push(10);
    pq.push(20);
    pq.push(15);
    cout << "Top element (Max-Heap): " << pq.top() << endl; // 20
    pq.pop();
    cout << "Top element after pop: " << pq.top() << endl; // 15
    return 0;
}
```

###### ржмрзНржпрж╛ржЦрзНржпрж╛: Priority Queue ржП рж╕рж░рзНржмрзЛржЪрзНржЪ ржЙржкрж╛ржжрж╛ржиржЯрж┐ (20) ржкрзНрж░ржержорзЗ ржмрзЗрж░ рж╣рзЯред

### 2. ржЕрзНржпрж╛ржбржнрж╛ржирзНрж╕ржб ржбрж╛ржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░ (Advanced Data Structures)
- Binary Tree (ржмрж╛ржЗржирж╛рж░рж┐ ржЯрзНрж░рж┐):
- ржПржХржЯрж┐ Binary Tree рж╣рж▓ ржПржоржи ржПржХржЯрж┐ ржЯрзНрж░рж┐ ржбрж╛ржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░ ржпрзЗржЦрж╛ржирзЗ ржкрзНрж░рждрж┐ржЯрж┐ ржирзЛржбрзЗрж░ рж╕рж░рзНржмрж╛ржзрж┐ржХ ржжрзБржЯрж┐ рж╕ржирзНрждрж╛ржи ржерж╛ржХрждрзЗ ржкрж╛рж░рзЗред
  
```cpp
 
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* left;
    Node* right;
};

int main() {
    Node* root = new Node();
    root->data = 1;
    root->left = new Node();
    root->right = new Node();
    root->left->data = 2;
    root->right->data = 3;
    
    cout << "Root: " << root->data << endl;
    cout << "Left Child: " << root->left->data << endl;
    cout << "Right Child: " << root->right->data << endl;
    
    return 0;
}
```
###### ржмрзНржпрж╛ржЦрзНржпрж╛: ржПржЦрж╛ржирзЗ ржПржХржЯрж┐ ржмрж╛ржЗржирж╛рж░рж┐ ржЯрзНрж░рж┐ рждрзИрж░рж┐ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ ржпрзЗржЦрж╛ржирзЗ Root ржПржмржВ рждрж╛рж░ Left ржУ Right рж╕ржирзНрждрж╛ржи ржирзЛржб рж░рзЯрзЗржЫрзЗред

### Binary Search Tree (BST):
- Binary Search Tree (BST) рж╣рж▓ ржПржХржЯрж┐ ржмрж╛ржЗржирж╛рж░рж┐ ржЯрзНрж░рж┐, ржпрзЗржЦрж╛ржирзЗ ржкрзНрж░рждрж┐ржЯрж┐ ржирзЛржбрзЗрж░ left рж╕ржирзНрждрж╛ржирзЗрж░ ржорж╛ржи рждрж╛рж░ ржирж┐ржЬрзЗрж░ ржорж╛ржирзЗрж░ ржЪрзЗрзЯрзЗ ржЫрзЛржЯ ржПржмржВ right рж╕ржирзНрждрж╛ржирзЗрж░ ржорж╛ржи рждрж╛рж░ ржирж┐ржЬрзЗрж░ ржорж╛ржирзЗрж░ ржЪрзЗрзЯрзЗ ржмрзЬ рж╣рзЯред

```cpp
 
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* left;
    Node* right;
};

Node* insert(Node* root, int value) {
    if (root == nullptr) {
        Node* newNode = new Node();
        newNode->data = value;
        newNode->left = newNode->right = nullptr;
        return newNode;
    }
    if (value < root->data) {
        root->left = insert(root->left, value);
    } else {
        root->right = insert(root->right, value);
    }
    return root;
}

int main() {
    Node* root = nullptr;
    root = insert(root, 10);
    root = insert(root, 20);
    root = insert(root, 5);
    
    cout << "Root: " << root->data << endl;   // 10
    cout << "Left Child: " << root->left->data << endl;  // 5
    cout << "Right Child: " << root->right->data << endl; // 20
    
    return 0;
}
```

###### ржмрзНржпрж╛ржЦрзНржпрж╛: ржПржЦрж╛ржирзЗ ржПржХржЯрж┐ BST рждрзИрж░рж┐ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ ржПржмржВ рждрж┐ржиржЯрж┐ ржорж╛ржи (10, 20, 5) ржЗржирж╕рж╛рж░рзНржЯ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред

### Heap (рж╣рж┐ржк):
- Heap ржПржХржЯрж┐ ржкрзВрж░рзНржг ржмрж╛ржЗржирж╛рж░рж┐ ржЯрзНрж░рж┐ ржпрж╛ рж╣рж┐ржк ржкрзНрж░ржкрж╛рж░рзНржЯрж┐ ржЕржирзБрж╕рж░ржг ржХрж░рзЗред ржПржЯрж┐ ржжрзБржЯрж┐ ржзрж░ржирзЗрж░ рж╣рждрзЗ ржкрж╛рж░рзЗ:
- Max-Heap: ржпрзЗржЦрж╛ржирзЗ ржкрзНрж░рждрж┐ржЯрж┐ ржирзЛржбрзЗрж░ ржорж╛ржи рждрж╛рж░ рж╕ржирзНрждрж╛ржирзЗрж░ ржорж╛ржирзЗрж░ ржЪрзЗрзЯрзЗ ржмрзЬред
- Min-Heap: ржпрзЗржЦрж╛ржирзЗ ржкрзНрж░рждрж┐ржЯрж┐ ржирзЛржбрзЗрж░ ржорж╛ржи рждрж╛рж░ рж╕ржирзНрждрж╛ржирзЗрж░ ржорж╛ржирзЗрж░ ржЪрзЗрзЯрзЗ ржЫрзЛржЯред
- 
```cpp
 
#include <iostream>
#include <queue>
using namespace std;

int main() {
    priority_queue<int> maxHeap;
    maxHeap.push(10);
    maxHeap.push(20);
    maxHeap.push(15);
    
    cout << "Max Heap Top: " << maxHeap.top() << endl;  // 20
    return 0;
}
```

######ржмрзНржпрж╛ржЦрзНржпрж╛: ржПржЦрж╛ржирзЗ Max-Heap ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ, ржпрзЗржЦрж╛ржирзЗ рж╕рж░рзНржмрзЛржЪрзНржЪ ржорж╛ржи (20) рж╢рзАрж░рзНрж╖рзЗ ржерж╛ржХрзЗред

### 3. рж╣рзНржпрж╛рж╢рж┐ржВ (Hashing)
- Hash Table (рж╣рзНржпрж╛рж╢ ржЯрзЗржмрж┐рж▓):
- Hash Table ржПржХржЯрж┐ ржбрж╛ржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░ ржпрж╛ ржХрзА-ржмрзЯрж╕рзА ржорж╛ржи рж╕ржВрж░ржХрзНрж╖ржг ржХрж░рзЗ ржПржмржВ ржжрзНрж░рзБржд ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕рзЗрж░ ржЬржирзНржп ржПржХржЯрж┐ рж╣рзНржпрж╛рж╢ ржлрж╛ржВрж╢ржи ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗред
- 
```cpp
 
#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    unordered_map<string, int> hashTable;
    hashTable["apple"] = 5;
    hashTable["banana"] = 3;
    
    cout << "Apple count: " << hashTable["apple"] << endl;
    return 0;
}
```

###### ржмрзНржпрж╛ржЦрзНржпрж╛: ржПржЦрж╛ржирзЗ unordered_map ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ ржпрж╛ ржПржХржЯрж┐ рж╣рзНржпрж╛рж╢ ржЯрзЗржмрж┐рж▓ рждрзИрж░рж┐ ржХрж░рзЗред

4. ржмрж┐ржЯ ржорзНржпрж╛ржирж┐ржкрзБрж▓рзЗрж╢ржи (Bit Manipulation)
AND, OR, XOR Operations (ржПржирзНржб, ржЕрж░, ржПржХрзНрж╕ржЕрж░ ржЕржкрж╛рж░рзЗрж╢ржи):
```cpp

#include <iostream>
using namespace std;

int main() {
    int a = 5; // 0101
    int b = 3; // 0011
    cout << "a & b: " << (a & b) << endl;  // AND operation
    cout << "a | b: " << (a | b) << endl;  // OR operation
    cout << "a ^ b: " << (a ^ b) << endl;  // XOR operation
    return 0;
}
```

###### ржмрзНржпрж╛ржЦрзНржпрж╛: ржПржЦрж╛ржирзЗ AND, OR, ржПржмржВ XOR ржЕржкрж╛рж░рзЗрж╢ржиржЧрзБрж▓рж┐ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред

### 5. Disjoint Set (Union-Find)

- Union by Rank (ржЗржЙржирж┐рзЯржи ржмрж╛ржЗ рж░рзНржпрж╛ржВржХ):
- Union-Find ржбрж╛ржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░ржЯрж┐ ржЙржкрж╛ржжрж╛ржиржЧрзБрж▓рж┐рж░ ржЧрзНрж░рзБржкрж┐ржВрзЯрзЗрж░ ржЬржирзНржп ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ рж╣рзЯ, ржпрзЗржЦрж╛ржирзЗ ржжрзБржЯрж┐ рж╕рзЗржЯрзЗрж░ ржЗржЙржирж┐рзЯржи ржХрж░рж╛ ржПржмржВ рждрж╛ржжрзЗрж░ ржоржзрзНржпрзЗ ржХрзЛржиржЯрж┐ ржмржбрж╝ рждрж╛ ржЯрзНрж░рзНржпрж╛ржХ ржХрж░рж╛ рж╣рзЯред

```cpp
#include <iostream>
#include <vector>
using namespace std;

class DisjointSet {
public:
    vector<int> parent, rank;
    
    DisjointSet(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
        }
    }
    
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        
        if (rootX != rootY) {
            if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else {
                parent[rootY] = rootX;
                ++rank[rootX];
            }
        }
    }
};

int main() {
    DisjointSet ds(5);
    ds.unite(0, 1);
    ds.unite(1, 2);
    cout << "Find(0): " << ds.find(0) << endl; // 0
    cout << "Find(2): " << ds.find(2) << endl; // 0
    return 0;
}
```

###### ржмрзНржпрж╛ржЦрзНржпрж╛: ржПржЦрж╛ржирзЗ Union-Find ржбрж╛ржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ ржпрж╛рждрзЗ ржжрзБржЯрж┐ рж╕рзЗржЯ ржПржХрждрзНрж░рж┐ржд ржХрж░рж╛ рж╣рзЯ ржПржмржВ рждрж╛ржжрзЗрж░ рж░рзБржЯ ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯред
 
